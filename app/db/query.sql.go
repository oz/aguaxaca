// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const completeImport = `-- name: CompleteImport :exec
UPDATE imports
SET completed_at = unixepoch(),
    runs = runs + 1
WHERE id = ?
`

func (q *Queries) CompleteImport(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, completeImport, id)
	return err
}

const countImportsByHash = `-- name: CountImportsByHash :one
SELECT COUNT(*) FROM imports
WHERE file_hash = ?
`

func (q *Queries) CountImportsByHash(ctx context.Context, fileHash int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countImportsByHash, fileHash)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDelivery = `-- name: CreateDelivery :one
INSERT INTO deliveries (
  date, schedule, location_type, location_name, created_at
) VALUES (
  ?, ?, ?, ?, unixepoch()
)
RETURNING id, date, schedule, location_type, location_name, created_at
`

type CreateDeliveryParams struct {
	Date         UnixTime `db:"date" json:"date"`
	Schedule     string   `db:"schedule" json:"schedule"`
	LocationType string   `db:"location_type" json:"location_type"`
	LocationName string   `db:"location_name" json:"location_name"`
}

func (q *Queries) CreateDelivery(ctx context.Context, arg CreateDeliveryParams) (Delivery, error) {
	row := q.db.QueryRowContext(ctx, createDelivery,
		arg.Date,
		arg.Schedule,
		arg.LocationType,
		arg.LocationName,
	)
	var i Delivery
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Schedule,
		&i.LocationType,
		&i.LocationName,
		&i.CreatedAt,
	)
	return i, err
}

const createImport = `-- name: CreateImport :one
INSERT INTO imports (
  file_path, file_hash, completed_at, runs, created_at
) VALUES (
  ?, ?, NULL, 0, unixepoch()
)
RETURNING id, file_path, file_hash, created_at, completed_at, failed_at, runs
`

type CreateImportParams struct {
	FilePath string `db:"file_path" json:"file_path"`
	FileHash int64  `db:"file_hash" json:"file_hash"`
}

func (q *Queries) CreateImport(ctx context.Context, arg CreateImportParams) (Import, error) {
	row := q.db.QueryRowContext(ctx, createImport, arg.FilePath, arg.FileHash)
	var i Import
	err := row.Scan(
		&i.ID,
		&i.FilePath,
		&i.FileHash,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.Runs,
	)
	return i, err
}

const deleteDelivery = `-- name: DeleteDelivery :exec
DELETE FROM deliveries
WHERE id = ?
`

func (q *Queries) DeleteDelivery(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDelivery, id)
	return err
}

const failImport = `-- name: FailImport :exec
UPDATE imports
SET failed_at = unixepoch(),
    runs = runs + 1
WHERE id = ?
`

func (q *Queries) FailImport(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, failImport, id)
	return err
}

const getDelivery = `-- name: GetDelivery :one
SELECT id, date, schedule, location_type, location_name, created_at FROM deliveries
WHERE id = ? LIMIT 1
`

func (q *Queries) GetDelivery(ctx context.Context, id int64) (Delivery, error) {
	row := q.db.QueryRowContext(ctx, getDelivery, id)
	var i Delivery
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Schedule,
		&i.LocationType,
		&i.LocationName,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestImport = `-- name: GetLatestImport :one
SELECT id, file_path, file_hash, created_at, completed_at, failed_at, runs FROM imports
WHERE completed_at IS NOT NULL
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestImport(ctx context.Context) (Import, error) {
	row := q.db.QueryRowContext(ctx, getLatestImport)
	var i Import
	err := row.Scan(
		&i.ID,
		&i.FilePath,
		&i.FileHash,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.Runs,
	)
	return i, err
}

const getPendingImports = `-- name: GetPendingImports :many
SELECT id, file_path, file_hash, created_at, completed_at, failed_at, runs FROM imports
WHERE completed_at IS NULL
AND runs < ?
ORDER BY created_at DESC
`

func (q *Queries) GetPendingImports(ctx context.Context, runs sql.NullInt64) ([]Import, error) {
	rows, err := q.db.QueryContext(ctx, getPendingImports, runs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Import
	for rows.Next() {
		var i Import
		if err := rows.Scan(
			&i.ID,
			&i.FilePath,
			&i.FileHash,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.Runs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveries = `-- name: ListDeliveries :many
SELECT id, date, schedule, location_type, location_name, created_at FROM deliveries
WHERE "date" > ?
ORDER BY "date" DESC
`

func (q *Queries) ListDeliveries(ctx context.Context, date UnixTime) ([]Delivery, error) {
	rows, err := q.db.QueryContext(ctx, listDeliveries, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Delivery
	for rows.Next() {
		var i Delivery
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Schedule,
			&i.LocationType,
			&i.LocationName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDeliveriesByName = `-- name: SearchDeliveriesByName :many
SELECT d.id, d.date, d.schedule, d.location_type, d.location_name, d.created_at
FROM deliveries d
JOIN deliveries_fts fts ON d.id = fts.id
WHERE d.date > ?
  AND fts.location_name MATCH ?
GROUP BY d.id
ORDER BY d.date DESC
`

type SearchDeliveriesByNameParams struct {
	Date         UnixTime `db:"date" json:"date"`
	LocationName string   `db:"location_name" json:"location_name"`
}

func (q *Queries) SearchDeliveriesByName(ctx context.Context, arg SearchDeliveriesByNameParams) ([]Delivery, error) {
	rows, err := q.db.QueryContext(ctx, searchDeliveriesByName, arg.Date, arg.LocationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Delivery
	for rows.Next() {
		var i Delivery
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Schedule,
			&i.LocationType,
			&i.LocationName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
